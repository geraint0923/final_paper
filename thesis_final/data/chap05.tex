

\chapter{性能回退判断算法的设计实现及优化}
由于我们设计和实现的是性能测试框架，因此在我们的框架中自然需要找到性能回退问题，而这就需要需要使用一个算法通过测试的结果来判断某一个版本的内核是否出现了性能回退问题。


\section{性能回退判断算法的设计}
要设计一个性能回退的判断算法，首先需要知道性能测试的结果有什么特征，然后才能根据这个数据上出现的特征来设计相应的算法。

\subsection{判断难点}
一般对于内核，我们会考察内核是否存在bug以及是否存在性能回退问题。

对于内核中的bug，能够进行比较容易的判断，因为内核中的bug在触发之后往往能够导致内核崩溃，出现kernel panic，通过判断kernel panic的出现，可以比较简单快捷地判断出来，而且进行内核bug判断的时候，我们一般并不需要使用过往的测试结果和判断结果。

从图\ref{fig:variation}中，我们还能发现性能测试的结果还会存在一定的波动。
\begin{figure}[H]
\centering
\includegraphics[width=10cm]{variation}
\caption{性能测试中的波动\cite{chen2007keeping}}
\label{fig:variation}
\end{figure}

综合上述，性能回退的判断更为困难，主要存在以下难点：
\begin{enumerate}
\item 每次进行测试的测试机很难实现硬件的统一和状态相似
\item 测试结果具有较大的波动性
\item 在进行判断的时候需要使用过往的测试结果作为参考
\end{enumerate}

因此，需要考虑这些性能回退判断的难点才能设计出比较科学合理的性能回退判断算法。
\subsection{测试前提}
为了尽可能排除测试机的硬件问题和状态问题造成的测试结果波动，我们要求每一次测试都必须要满足下面的前提：
\begin{enumerate}
\item 用于测试的文件系统镜像需要比较精简，而且在尽可能精减在启动时运行的服务数量。这样做的目的是尽可能减少在开机时启动的进程或者任务数量，从而达到减少其他程序干扰的目的。
\item 系统启动之后立刻进行性能测试，系统刚刚启动结束之后，内核的环境刚刚初始化，不会有其他的干扰。
\item 每一次启动后都尽量只进行一次测试，如果进行多次测试，那么在每一次的测试结束之后，内核的状态都是处于一种未知的状态，而内核状态的差异往往很容易加剧测试数据的波动。
\item 每一次的测试需要持续较长的时间，持续较长时间的测试可以使得测试的运行趋于稳定，从而降低环境中噪声对测试结果的干扰。
\end{enumerate}
\subsection{设计思路}
在前面的测试前提之下，我们能做到的仅仅是降低测试结果的波动，但是，波动是没有办法彻底消除的，因此，我们还需要在一定的波动范围内进行判断。

要在有波动的情况作出判断，我们最直观的感觉就是需要使用历史的测试数据来作为参考。

我们可以首先利用历史数据估计出波动可能的大小，然后利用这个估计出来的波动可能大小，我们可以估计楚本次测试正常值的范围，那么当最终的测试结果超出了这个正常的范围的时候，我们在测试框架中会通报一次异常，当然，异常可能是出现了性能上的提升，也可能是出现了性能回退问题，无论是性能提升，还是性能下降，都是非常值得我们关注的。

这其中仍旧存在这一个问题，那就是随着时间的变化，测试结果的理论合理范围也是会发生变化的，因此，我们在进行判断时所选取的历史数据应该是尽可能新的。

在这样的思路下，我们设计了下一部分将要提到的算法。

\subsection{算法设计}
在判断某个版本的内核是否出现了性能回退的时候我们给的范围应该比较宽松，，而在bisect的过程中，我们则应该把握一个比较严格的尺度，因此，在两种情况下进行的性能回退判断算法应该是有所不同的。

\subsubsection{性能回退判断算法}
这里介绍的是在对HEAD版本进行性能回退判断的算法。

我们的算法从逻辑上来讲是比较简单的，在每次进行判断之前我们先把本次的测试结果$x$添加到历史记录中，在进行判断的时候，我们只是用最新的100个历史记录，因此，在加入本次测试结果之后，会把原来最旧的数据移除。在最新的100个数据中，我们会除去最高的3个数据以及最低的3个数据，然后我们在剩下的94个数据中找到最高的$M$和最低的$m$，这时候判断$x$是否满足
\begin{equation}
\label{equ:pr-judge}
m<x<M
\end{equation}
如果满足式\ref{equ:pr-judge}，那么我们可以认为本次测试的结果是在正常的范围内，不用进行bisect；否则，我们认为本次测试的结果是不正常的，通报异常，然后根据是否是性能回退来决定是否进行bisect操作。

用伪代码表示为算法\ref{alg:old_alg}。

\begin{algorithm}
\caption{性能回退判断算法}
\label{alg:old_alg}
\KwIn{历史测试数据集合 $Hist$, 本次测试结果$x$}
\KwOut{是否异常$isException$}
$isException$ = false\;

从$Hist$中去除最旧的数据\;
add $x$ to $Hist$\;
从$Hist$中删去最大的三个数据\;
从$Hist$中删去最小的三个数据\;
$m$ = $\min(Hist)$\;
$M$ = $\max(Hist)$\;
\If{$x$ < $m$ or $x$ > $M$}
{
	$isException$ = true\;
}
return $isException$\;
\end{algorithm}


\subsubsection{bisect过程中的判断算法}
在本部分介绍的是在bisect过程中所执行的性能回退判断算法。

在bisect的过程中，我们能够知道的是一个没有问题的版本A，和出现性能问题的版本B，我们将两者的测试数据分别记为$x_{good}$和$x_{bad}$，不妨假设$x_{good} > x_{bad}$，本次测试结果则为$x$，然后我们计算$x_{good}$和$x_{bad}$的中间值$x_{mid}$：
\begin{equation}
\label{equ:pr-mid}
x_{mid} = \frac{1}{2} (x_{good} + x_{bad})
\end{equation}
然后我们判断下面的不等式是否成立：
\begin{equation}
\label{equ:pr-bisect}
x \leq x_{mid}
\end{equation}
如果式\ref{equ:pr-bisect}是成立的，那么说明本次测试的结果比较靠近出现问题的版本，那么我们将把本次测试的版本也标记为出现问题，即bad；否则，说明本次测试de结果靠近没有问题的版本，那么将该版本标记为没有问题，即good。

用伪代码表示为算法\ref{alg:bisect_alg}。

\begin{algorithm}
\caption{bisect过程中的判断算法}
\label{alg:bisect_alg}
\KwIn{好的测试数据$x_{good}$, 坏的测试数据$x_{bad}$, 当前测试数据$x$}
\KwOut{当前数据是否是好的$isGood$}
$isGood$ = true\;
$x_{mid} = \frac{1}{2}(x_{good} + x_{bad})$\;
\If{$x_{good} > x_{bad}$}
{
	\If{$x \leq x_{mid}$}
	{
		$isGood$ = false\;
	}
}
\Else
{
	\If{$x \geq x_{mid}$}
	{
		$isGood$ = false\;
	}
}
return $isGood$\;
\end{algorithm}

\section{性能回退判断算法的实现}
在介绍我们的测试框架结构的章节中，我们已经介绍过，为了提高内核编译系统和测试管理系统之间配合的效率，我们将所有的通信实现为异步的形式。

测试机会在测试结束之后通知测试管理服务器，让测试管理服务器着手处理新产生的测试数据，在测试管理服务器完成了测试结果的格式化和分析处理之后，就会根据本次测试的配置文件来决定采用何种性能回退判断算法。

\section{性能回退判断算法的优化}
事实上，在上面的判断算法中还存在着一个比较严重的问题，那就是对于一个非稳定版的Linux来说，本身可能就存在着一定的性能回退，如果我们把这样版本的测试数据添加到了历史记录中，那么无形中，我们就把性能测试结果的合理范围扩大了，这将导致我们可能会漏过某些潜在的性能回退问题。


这需要我们合理地缩小性能测试结果的正常范围。

我们知道，在每一个发行版本（包括RC和稳定版）的Linux内核版本发布之前都会对加入内核代码中的新的patchset进行测试，如果测试之后没有发现性能回退问题或者bug，那么新的patchset才会被接受，否则将会被剔除出内核代码中。因此，我们可以认为，Linux内核的每一个发行版本（包括RC和稳定版）都是比较稳定的，可以使用其测试结果作为可以参考的历史数据，这样我们能够获得一个更加合理更加可信的一个测试结果正常范围。


对于原来的判断算法，我们只需要在将本次测试结果加入到历史记录之前判断当前的内核版本是否是一个发行版本即可，如果当前的版本是一个发行版本，那么就将测试结果加入到历史记录中去，否则就不将测试结果加入到历史记录中。

在实现上，我们只需要判断内核版本是否具有一个tag，这是因为Linux代码树中，所有的发行版本都被打上了tag，而在代码上，git这个代码版本管理工具已经提供了一个命令能让我们知道当前的版本的tag：
\begin{center}
git tag --points-at \$COMMIT\_ID
\end{center}

在优化之后，性能回退判断算法的伪代码为算法\ref{alg:opt_alg}。


\begin{algorithm}
\caption{优化后的性能回退判断算法}
\label{alg:opt_alg}
\KwIn{历史测试数据集合 $Hist$, 本次测试结果$x$, 当前版本$V$}
\KwOut{是否异常$isException$}
$isException$ = false\;
\If{hasTag(V)}
{
	从$Hist$中去除最旧的数据\;
	add $x$ to $Hist$\;
}
从$Hist$中删去最大的三个数据\;
从$Hist$中删去最小的三个数据\;
$m$ = $\min(Hist)$\;
$M$ = $\max(Hist)$\;
\If{$x$ < $m$ or $x$ > $M$}
{
	$isException$ = true\;
}
return $isException$\;
\end{algorithm}
